     1                                  ; =======================================================================
     2                                  ; int myprintf(const char *format, ...)
     3                                  ; Supported specifiers:
     4                                  ;   - %c - one character;
     5                                  ;   - %s - a c-string;
     6                                  ;   - %% - a single '%';
     7                                  ;   - %d - decimal integer (int32_t)
     8                                  ;   - %x - hex integer (uint32_t)
     9                                  ;   - %o - octal integer (uint32_t)
    10                                  ;   - %b - binary integer (uint32_t)
    11                                  ; =======================================================================
    12                                  
    13                                  %define GLOBAL_FUNC_NAME _Z9my_printfPKcz
    14                                  %define CHARBUF_SIZE 16
    15                                  
    16                                  global GLOBAL_FUNC_NAME
    17                                  ;//TODO - исправить rsi на esi, потому что блин int, а не long
    18                                  section .text
    19                                  
    20                                  GLOBAL_FUNC_NAME:
    21                                              ; ============================================    
    22                                              ; preparing stack frame, so that all POTENTIAL
    23                                              ; arguments are located in order in stack
    24                                  
    25 00000000 415A                                pop r10 ; saving ret code
    26                                  
    27                                              ; pushing POTENTIAL arguments in reverse order
    28 00000002 4151                                push r9
    29 00000004 4150                                push r8
    30 00000006 51                                  push rcx
    31 00000007 52                                  push rdx
    32 00000008 56                                  push rsi
    33                                  
    34 00000009 4989E3                              mov r11, rsp ; saving reference stack pointer
    35                                  
    36 0000000C 4152                                push r10 ; pushing ret code
    37                                  
    38                                              ; ============================================
    39 0000000E 53                                  push rbx
    40 0000000F 55                                  push rbp
    41 00000010 4154                                push r12
    42 00000012 4155                                push r13
    43 00000014 4156                                push r14
    44 00000016 4157                                push r15
    45                                  
    46 00000018 4C89DD                              mov rbp, r11 ; now r11 is free
    47                                  
    48                                              ; before first call of print_char
    49 0000001B 31C0                                xor eax, eax
    50 0000001D 4D31DB                              xor r11, r11
    51 00000020 4D31D2                              xor r10, r10
    52                                  
    53                                              ; =====================================
    54                                              ; main loop
    55 00000023 448A17                  main_loop:  mov r10b, [rdi]
    56 00000026 48FFC7                              inc rdi
    57                                              
    58 00000029 4180FA25                            cmp r10b, '%'
    59 0000002D 7413                                je specf
    60                                              
    61 0000002F 4180FA5C                            cmp r10b, '\'
    62 00000033 7415                                je slash
    63                                  
    64                                              ; common char or 0x0
    65 00000035 E825000000                          call print_char
    66                                  
    67 0000003A 4180FA00                            cmp r10b, 0x0
    68 0000003E 75E3                                jne main_loop
    69 00000040 EB0A                                jmp printf_end
    70                                              ; ---------------
    71                                              ; specf
    72 00000042 448A17                  specf:      mov r10b, [rdi]
    73 00000045 48FFC7                              inc rdi
    74 00000048 EB5F                                jmp hndl_specf
    75                                  
    76                                              ; ---------------
    77                                              ; slash
    78                                  slash:
    79                                  
    80                                              ; ------------------------------------
    81                                              ; back to loop, if not 0x0
    82                                  hndl_specf_end:
    83 0000004A EBD7                                jmp main_loop
    84                                              ; =====================================
    85                                              ; end of main_loop
    86                                  printf_end: 
    87                                  
    88 0000004C 415F                                pop r15
    89 0000004E 415E                                pop r14
    90 00000050 415D                                pop r13
    91 00000052 415C                                pop r12
    92 00000054 5D                                  pop rbp
    93 00000055 5B                                  pop rbx
    94                                  
    95                                              ; ======================================
    96                                              ; fixig stack frame and ret
    97                                  
    98 00000056 415B                                pop r11         ; popping ret code
    99 00000058 4883C428                            add rsp, 5*8    ; throwing out potential register args
   100 0000005C 4153                                push r11        ; ret code
   101 0000005E C3                                  ret
   102                                  
   103                                  ; =======================================================================
   104                                  ; print_char
   105                                  ; Description:
   106                                  ;   Gets one char, stores it into internal buffer. When it's full, calls
   107                                  ;   syscall write to stdout and resets the buffer. If given char is zero 
   108                                  ;   byte ('\0'), doesn't store it and flushes buffer immediately. 
   109                                  ;   Increments number of written bytes (see args) or sets it to -1 in 
   110                                  ;   case of writing error.
   111                                  ; Args:
   112                                  ;   - r10b - char to store to buffer and print.
   113                                  ;   - eax  - stores number of already written bytes here, or sets it to -1
   114                                  ;           in case of error.
   115                                  ; Expects: 
   116                                  ;   - r11 - index in the buffer, must be set to 0 before first call of 
   117                                  ;           this func; must not be changed outside of this func.
   118                                  ; =======================================================================
   119                                  print_char:
   120 0000005F 4180FA00                            cmp r10b, 0x0
   121 00000063 7416                                je flush_buf
   122                                  
   123 00000065 83F8FF                              cmp eax, -1     ; check if error already happened
   124 00000068 7437                                je prn_chr_end
   125                                  
   126 0000006A 458893[00000000]                    mov [charbuf + r11], r10b
   127 00000071 49FFC3                              inc r11
   128                                  
   129 00000074 4983FB10                            cmp r11, CHARBUF_SIZE
   130 00000078 7401                                je flush_buf
   131                                              
   132 0000007A C3                                  ret
   133                                  
   134                                  flush_buf:  
   135 0000007B 57                                  push rdi
   136 0000007C 56                                  push rsi
   137 0000007D 52                                  push rdx
   138 0000007E 50                                  push rax 
   139                                  
   140 0000007F 4C89DA                              mov rdx, r11            ; num of bytes to write
   141 00000082 B801000000                          mov rax, 0x1            ; syscall number - write
   142 00000087 BF01000000                          mov rdi, 0x1            ; stdout
   143 0000008C 488D3425[00000000]                  lea rsi, [charbuf]      ; buffer pointer
   144 00000094 0F05                                syscall
   145                                  
   146                                              ; now eax stores -1 or number of written bytes
   147 00000096 83F8FF                              cmp eax, -1
   148 00000099 7406                                je prn_chr_end
   149 0000009B 030424                              add eax, [rsp] ; adding to eax its previous value 
   150                                  
   151 0000009E 4D31DB                              xor r11, r11
   152                                  
   153                                  prn_chr_end: 
   154                                              ; if eax equals -1, it must be -1 still; otherwise
   155                                              ; it already has the needed value
   156 000000A1 4883C408                            add rsp, 0x8    ; skipping eax
   157                                  
   158 000000A5 5A                                  pop rdx
   159 000000A6 5E                                  pop rsi
   160 000000A7 5F                                  pop rdi
   161 000000A8 C3                                  ret
   162                                  
   163                                  ; =======================================================================
   164                                  ; hndl_specf - DON'T USE CALL, USE JMP
   165                                  ; Description:
   166                                  ;   Handles situation when specifier like '%S' is met in the format 
   167                                  ;   string. 'S' fully specifier which specifier it is.
   168                                  ; Supported specifiers (case sensitive!):
   169                                  ;   - %%    - just one character '%'   - no arg;
   170                                  ;   - %c    - one character            - uint8_t (unsigned char)
   171                                  ;   - %s    - C-string                 - const char *
   172                                  ;   - %d    - decimal integer          - int32_t
   173                                  ;   - %x    - hex integer              - int32_t
   174                                  ;   - %o    - octal integer            - int32_t
   175                                  ;   - %b    - binary integer           - int32_t
   176                                  ; Arguments:
   177                                  ;   - r10   - the character 'S' (see description)
   178                                  ; Expects:
   179                                  ;   - rbp - to point at the next to be used argument in stack 
   180                                  ;           (considering all args as 8 bytes)
   181                                  ; ATTENTION:
   182                                  ;   Nothing happens if the specifier is not identified.
   183                                  ; =======================================================================
   184                                  hndl_specf:
   185                                  %define SPECF_SMALLEST 'b' ; specifier with the smallest ascii value
   186                                  %define SPECF_BIGGEST  'x' ; specifier with the biggest ascii value
   187                                  
   188 000000A9 4180FA25                            cmp r10b, '%'           ; doesn't need arg, handled separately
   189 000000AD 741A                                je specf_perc
   190                                  
   191 000000AF 4180FA78                            cmp r10b, SPECF_BIGGEST ; if unrecognized, skip
   192 000000B3 7795                                ja hndl_specf_end       
   193                                  
   194                                              ; all the rest need an arg, getting it into rsi
   195 000000B5 488B7500                            mov rsi, [rbp]
   196 000000B9 4883C508                            add rbp, 0x8
   197                                  
   198                                              ; and now jmp to corresponding specifier handler
   199 000000BD 4180EA62                            sub r10b, SPECF_SMALLEST
   200 000000C1 42FF24D5[20000000]                  jmp [jmp_table + r10*8]
   201                                  
   202                                              ; treating '%%' specially
   203 000000C9 E891FFFFFF              specf_perc: call print_char ; just print '%', which is already in the r10b 
   204 000000CE E977FFFFFF                          jmp hndl_specf_end
   205                                  
   206                                              ; there is no ret, because every specifier handler jmps to
   207                                              ; label 'hndl_specf_end', which is located in the main loop
   208                                  ; =======================================================================
   209                                  ; Specifiers handlers. 
   210                                  ; Expects:
   211                                  ;    Each of them expects the argument to be in rsi.
   212                                  ; ==========================================================================
   213                                  ; Macro for converting & printing, supports BIN, HEX (AND POTENTIALLY BASE 4)
   214                                  ; Macro argumets:
   215                                  ;   %1) number of bits to represent one digit (1 for BIN, 4 for HEX, etc)
   216                                  ;   %2) BIN | HEX
   217                                  ; Expects:
   218                                  ;   Number to convert and print in rsi
   219                                  ; ==========================================================================
   220                                  %macro      ConvertBH 2
   221                                  
   222                                              xor rbx, rbx
   223                                  
   224                                              ; skipping leading zeroes
   225                                              mov ecx, 64 / %1
   226                                  %%nzero:    rol rsi, %1
   227                                              mov bl, sil
   228                                              and bl, (1 << %1) - 1
   229                                              cmp bl, 0
   230                                              loope %%nzero
   231                                  
   232                                              jz %%num_0    ; the number to print is zero, special case
   233                                              ror rsi, %1
   234                                              inc ecx
   235                                  
   236                                  %%loop:     rol rsi, %1
   237                                              mov bl, sil
   238                                              and bl, (1 << %1) - 1
   239                                              mov r10b, [%2 + rbx]
   240                                              mov r12, rcx ; saving
   241                                              call print_char
   242                                              mov rcx, r12  
   243                                              loop %%loop
   244                                  
   245                                              jmp hndl_specf_end ; instead of ret
   246                                  
   247                                              ; if the number to print is 0
   248                                  %%num_0:    mov r10b, [%2]
   249                                              call print_char
   250                                  
   251                                              jmp hndl_specf_end ; instead of ret
   252                                  
   253                                  %endmacro
   254                                  ; ==========================================================================
   255                                  ; Macro for converting into bases [2, 10]
   256                                  ; Macro argumets:
   257                                  ;   %1) the base: 2, or 3, or 4... or 10
   258                                  ; Expects:
   259                                  ;   Number to convert and print in esi
   260                                  ; ==========================================================================
   261                                  %macro      ConvertCmn 1
   262                                              mov r12, rax    ; saving
   263                                  
   264                                              ; --------------------------------------------------------------
   265                                              ; if the base is 10 and number < 0, print '-' and turn off the highest bit
   266                                  %if %1 == 10
   267                                              test esi, 1 << 31
   268                                              jz %%skip_abs
   269                                              mov r10b, '-'
   270                                              call print_char
   271                                              and esi, (1 << 32) - 1 - (1 << 31)
   272                                  %endif
   273                                  
   274                                  %%skip_abs: 
   275                                              xor rdx, rdx
   276                                              xor rax, rax
   277                                              mov eax, esi
   278                                              mov ebx, %1 ; because div doesn't support immc
   279                                              xor rcx, rcx
   280                                  
   281                                  %%loop_fw:  div ebx
   282                                              push rdx
   283                                              inc rcx
   284                                              xor rdx, rdx
   285                                              cmp eax, 0
   286                                              jne %%loop_fw
   287                                              
   288                                              mov rax, r12 ; restoring rax
   289                                  
   290                                  %%loop_bw:  pop r10
   291                                              add r10, '0'
   292                                              mov r12, rcx    ; saving
   293                                              call print_char
   294                                              mov rcx, r12
   295                                              loop %%loop_bw
   296                                  
   297                                  %endmacro
   298                                  ; ==========================================================================
   299                                  specf_b:    ConvertBH 1, BIN
   299                              <1> specf_b: 
   221                              <1> 
   222 000000D3 4831DB              <1>  xor rbx, rbx
   223                              <1> 
   224                              <1> 
   225 000000D6 B940000000          <1>  mov ecx, 64 / %1
   226 000000DB 48D1C6              <1> %%nzero: rol rsi, %1
   227 000000DE 4088F3              <1>  mov bl, sil
   228 000000E1 80E301              <1>  and bl, (1 << %1) - 1
   229 000000E4 80FB00              <1>  cmp bl, 0
   230 000000E7 E1F2                <1>  loope %%nzero
   231                              <1> 
   232 000000E9 7427                <1>  jz %%num_0
   233 000000EB 48D1CE              <1>  ror rsi, %1
   234 000000EE FFC1                <1>  inc ecx
   235                              <1> 
   236 000000F0 48D1C6              <1> %%loop: rol rsi, %1
   237 000000F3 4088F3              <1>  mov bl, sil
   238 000000F6 80E301              <1>  and bl, (1 << %1) - 1
   239 000000F9 448A93[18000000]    <1>  mov r10b, [%2 + rbx]
   240 00000100 4989CC              <1>  mov r12, rcx
   241 00000103 E857FFFFFF          <1>  call print_char
   242 00000108 4C89E1              <1>  mov rcx, r12
   243 0000010B E2E3                <1>  loop %%loop
   244                              <1> 
   245 0000010D E938FFFFFF          <1>  jmp hndl_specf_end
   246                              <1> 
   247                              <1> 
   248 00000112 448A1425[18000000]  <1> %%num_0: mov r10b, [%2]
   249 0000011A E840FFFFFF          <1>  call print_char
   250                              <1> 
   251 0000011F E926FFFFFF          <1>  jmp hndl_specf_end
   252                              <1> 
   300                                  
   301 00000124 E921FFFFFF                          jmp hndl_specf_end ; instead of ret
   302                                  ; ==========================================================================
   303 00000129 4989F2                  specf_c:    mov r10, rsi
   304 0000012C E82EFFFFFF                          call print_char
   305 00000131 E914FFFFFF                          jmp hndl_specf_end ; instead of ret
   306                                  ; ==========================================================================
   307                                  specf_d:    ConvertCmn 10
   307                              <1> specf_d: 
   262 00000136 4989C4              <1>  mov r12, rax
   263                              <1> 
   264                              <1> 
   265                              <1> 
   266                              <1> %if %1 == 10
   267 00000139 F7C600000080        <1>  test esi, 1 << 31
   268 0000013F 740E                <1>  jz %%skip_abs
   269 00000141 41B22D              <1>  mov r10b, '-'
   270 00000144 E816FFFFFF          <1>  call print_char
   271 00000149 81E6FFFFFF7F        <1>  and esi, (1 << 32) - 1 - (1 << 31)
   272                              <1> %endif
   273                              <1> 
   274                              <1> %%skip_abs:
   275 0000014F 4831D2              <1>  xor rdx, rdx
   276 00000152 4831C0              <1>  xor rax, rax
   277 00000155 89F0                <1>  mov eax, esi
   278 00000157 BB0A000000          <1>  mov ebx, %1
   279 0000015C 4831C9              <1>  xor rcx, rcx
   280                              <1> 
   281 0000015F F7F3                <1> %%loop_fw: div ebx
   282 00000161 52                  <1>  push rdx
   283 00000162 48FFC1              <1>  inc rcx
   284 00000165 4831D2              <1>  xor rdx, rdx
   285 00000168 83F800              <1>  cmp eax, 0
   286 0000016B 75F2                <1>  jne %%loop_fw
   287                              <1> 
   288 0000016D 4C89E0              <1>  mov rax, r12
   289                              <1> 
   290 00000170 415A                <1> %%loop_bw: pop r10
   291 00000172 4983C230            <1>  add r10, '0'
   292 00000176 4989CC              <1>  mov r12, rcx
   293 00000179 E8E1FEFFFF          <1>  call print_char
   294 0000017E 4C89E1              <1>  mov rcx, r12
   295 00000181 E2ED                <1>  loop %%loop_bw
   296                              <1> 
   308                                  
   309 00000183 E9C2FEFFFF                          jmp hndl_specf_end
   310                                  ; ==========================================================================
   311                                  specf_o:    ConvertCmn 8
   311                              <1> specf_o: 
   262 00000188 4989C4              <1>  mov r12, rax
   263                              <1> 
   264                              <1> 
   265                              <1> 
   266                              <1> %if %1 == 10
   267                              <1>  test esi, 1 << 31
   268                              <1>  jz %%skip_abs
   269                              <1>  mov r10b, '-'
   270                              <1>  call print_char
   271                              <1>  and esi, (1 << 32) - 1 - (1 << 31)
   272                              <1> %endif
   273                              <1> 
   274                              <1> %%skip_abs:
   275 0000018B 4831D2              <1>  xor rdx, rdx
   276 0000018E 4831C0              <1>  xor rax, rax
   277 00000191 89F0                <1>  mov eax, esi
   278 00000193 BB08000000          <1>  mov ebx, %1
   279 00000198 4831C9              <1>  xor rcx, rcx
   280                              <1> 
   281 0000019B F7F3                <1> %%loop_fw: div ebx
   282 0000019D 52                  <1>  push rdx
   283 0000019E 48FFC1              <1>  inc rcx
   284 000001A1 4831D2              <1>  xor rdx, rdx
   285 000001A4 83F800              <1>  cmp eax, 0
   286 000001A7 75F2                <1>  jne %%loop_fw
   287                              <1> 
   288 000001A9 4C89E0              <1>  mov rax, r12
   289                              <1> 
   290 000001AC 415A                <1> %%loop_bw: pop r10
   291 000001AE 4983C230            <1>  add r10, '0'
   292 000001B2 4989CC              <1>  mov r12, rcx
   293 000001B5 E8A5FEFFFF          <1>  call print_char
   294 000001BA 4C89E1              <1>  mov rcx, r12
   295 000001BD E2ED                <1>  loop %%loop_bw
   296                              <1> 
   312                                  
   313 000001BF E986FEFFFF                          jmp hndl_specf_end
   314                                  ; ==========================================================================
   315                                  specf_s:
   316                                  
   317                                  ; ==========================================================================
   318                                  specf_x:    ConvertBH 4, HEX
   318                              <1> specf_x: 
   221                              <1> 
   222 000001C4 4831DB              <1>  xor rbx, rbx
   223                              <1> 
   224                              <1> 
   225 000001C7 B910000000          <1>  mov ecx, 64 / %1
   226 000001CC 48C1C604            <1> %%nzero: rol rsi, %1
   227 000001D0 4088F3              <1>  mov bl, sil
   228 000001D3 80E30F              <1>  and bl, (1 << %1) - 1
   229 000001D6 80FB00              <1>  cmp bl, 0
   230 000001D9 E1F1                <1>  loope %%nzero
   231                              <1> 
   232 000001DB 7429                <1>  jz %%num_0
   233 000001DD 48C1CE04            <1>  ror rsi, %1
   234 000001E1 FFC1                <1>  inc ecx
   235                              <1> 
   236 000001E3 48C1C604            <1> %%loop: rol rsi, %1
   237 000001E7 4088F3              <1>  mov bl, sil
   238 000001EA 80E30F              <1>  and bl, (1 << %1) - 1
   239 000001ED 448A93[00000000]    <1>  mov r10b, [%2 + rbx]
   240 000001F4 4989CC              <1>  mov r12, rcx
   241 000001F7 E863FEFFFF          <1>  call print_char
   242 000001FC 4C89E1              <1>  mov rcx, r12
   243 000001FF E2E2                <1>  loop %%loop
   244                              <1> 
   245 00000201 E944FEFFFF          <1>  jmp hndl_specf_end
   246                              <1> 
   247                              <1> 
   248 00000206 448A1425[00000000]  <1> %%num_0: mov r10b, [%2]
   249 0000020E E84CFEFFFF          <1>  call print_char
   250                              <1> 
   251 00000213 E932FEFFFF          <1>  jmp hndl_specf_end
   252                              <1> 
   319                                  
   320 00000218 E92DFEFFFF                          jmp hndl_specf_end ; instead of ret
   321                                  ; ==========================================================================
   322                                  section .rodata
   323 00000000 303132333435363738-     HEX:        db '0123456789ABCDEF' 
   323 00000009 39414243444546     
   324 00000010 3031323334353637        OCT:        db '01234567'
   325 00000018 3031                    BIN:        db '01'
   326                                  
   327 0000001A 90<rep 6h>              align 8
   328                                  jmp_table:
   329 00000020 [D300000000000000]      dq specf_b
   330 00000028 [2901000000000000]      dq specf_c
   331 00000030 [3601000000000000]      dq specf_d
   332 00000038 [4A00000000000000]      dq hndl_specf_end
   333 00000040 [4A00000000000000]      dq hndl_specf_end
   334 00000048 [4A00000000000000]      dq hndl_specf_end
   335 00000050 [4A00000000000000]      dq hndl_specf_end
   336 00000058 [4A00000000000000]      dq hndl_specf_end
   337 00000060 [4A00000000000000]      dq hndl_specf_end
   338 00000068 [4A00000000000000]      dq hndl_specf_end
   339 00000070 [4A00000000000000]      dq hndl_specf_end
   340 00000078 [4A00000000000000]      dq hndl_specf_end
   341 00000080 [4A00000000000000]      dq hndl_specf_end
   342 00000088 [8801000000000000]      dq specf_o
   343 00000090 [4A00000000000000]      dq hndl_specf_end
   344 00000098 [4A00000000000000]      dq hndl_specf_end
   345 000000A0 [4A00000000000000]      dq hndl_specf_end
   346 000000A8 [C401000000000000]      dq specf_s
   347 000000B0 [4A00000000000000]      dq hndl_specf_end
   348 000000B8 [4A00000000000000]      dq hndl_specf_end
   349 000000C0 [4A00000000000000]      dq hndl_specf_end
   350 000000C8 [4A00000000000000]      dq hndl_specf_end
   351 000000D0 [C401000000000000]      dq specf_x
   352                                  
   353                                  section .data
   354                                  
   355 00000000 000000000000000000-     charbuf: db CHARBUF_SIZE dup(0)
   355 00000009 00000000000000     
