     1                                  ; =======================================================================
     2                                  ; int myprintf(const char *format, ...)
     3                                  ; Supported specifiers:
     4                                  ;   - %c - one character;
     5                                  ;   - %s - a c-string;
     6                                  ;   - %% - a single '%';
     7                                  ;   - %d - decimal integer (int32_t)
     8                                  ;   - %x - hex integer (int32_t)
     9                                  ;   - %o - octal integer (int32_t)
    10                                  ;   - %b - binary integer (int32_t)
    11                                  ; =======================================================================
    12                                  
    13                                  %define GLOBAL_FUNC_NAME _Z9my_printfPKcz
    14                                  %define CHARBUF_SIZE 10
    15                                  
    16                                  global GLOBAL_FUNC_NAME
    17                                  
    18                                  section .text
    19                                  
    20                                  ;//REVIEW - про jmp вместо call и ret
    21                                  
    22                                  GLOBAL_FUNC_NAME:
    23                                              ; ============================================    
    24                                              ; preparing stack frame, so that all POTENTIAL
    25                                              ; arguments are located in order in stack
    26                                  
    27 00000000 415A                                pop r10 ; saving ret code
    28                                  
    29                                              ; pushing POTENTIAL arguments in reverse order
    30 00000002 4151                                push r9
    31 00000004 4150                                push r8
    32 00000006 51                                  push rcx
    33 00000007 52                                  push rdx
    34 00000008 56                                  push rsi
    35                                  
    36 00000009 4989E3                              mov r11, rsp ; saving reference stack pointer
    37                                  
    38 0000000C 4152                                push r10 ; pushing ret code
    39                                  
    40                                              ; ============================================
    41 0000000E 53                                  push rbx
    42 0000000F 55                                  push rbp
    43 00000010 4154                                push r12
    44 00000012 4155                                push r13
    45 00000014 4156                                push r14
    46 00000016 4157                                push r15
    47                                  
    48 00000018 4C89DD                              mov rbp, r11 ; now r11 is free
    49                                  
    50                                              ; before first call of print_char
    51 0000001B 31C0                                xor eax, eax
    52 0000001D 4D31DB                              xor r11, r11
    53 00000020 4D31D2                              xor r10, r10
    54                                  
    55                                              ; =====================================
    56                                              ; main loop
    57 00000023 448A17                  main_loop:  mov r10b, [rdi]
    58 00000026 48FFC7                              inc rdi
    59                                              
    60 00000029 4180FA25                            cmp r10b, '%'
    61 0000002D 7413                                je specf
    62                                              
    63 0000002F 4180FA5C                            cmp r10b, '\'
    64 00000033 7415                                je slash
    65                                  
    66                                              ; common char or 0x0
    67 00000035 E825000000                          call print_char
    68                                  
    69 0000003A 4180FA00                            cmp r10b, 0x0
    70 0000003E 75E3                                jne main_loop
    71 00000040 EB0A                                jmp printf_end
    72                                              ; ---------------
    73                                              ; specf
    74 00000042 448A17                  specf:      mov r10b, [rdi]
    75 00000045 48FFC7                              inc rdi
    76 00000048 EB5F                                jmp hndl_specf
    77                                  
    78                                              ; ---------------
    79                                              ; slash
    80                                  slash:
    81                                  
    82                                              ; ------------------------------------
    83                                              ; back to loop, if not 0x0
    84                                  hndl_specf_end:
    85 0000004A EBD7                                jmp main_loop
    86                                              ; =====================================
    87                                              ; end of main_loop
    88                                  printf_end: 
    89                                  
    90 0000004C 415F                                pop r15
    91 0000004E 415E                                pop r14
    92 00000050 415D                                pop r13
    93 00000052 415C                                pop r12
    94 00000054 5D                                  pop rbp
    95 00000055 5B                                  pop rbx
    96                                  
    97                                              ; ======================================
    98                                              ; fixig stack frame and ret
    99                                  
   100 00000056 415B                                pop r11         ; popping ret code
   101 00000058 4883C428                            add rsp, 5*8    ; throwing out potential register args
   102 0000005C 4153                                push r11        ; ret code
   103 0000005E C3                                  ret
   104                                  
   105                                  ; =======================================================================
   106                                  ; print_char
   107                                  ; Description:
   108                                  ;   Gets one char, stores it into internal buffer. When it's full, calls
   109                                  ;   syscall write to stdout and resets the buffer. If given char is zero 
   110                                  ;   byte ('\0'), doesn't store it and flushes buffer immediately. 
   111                                  ;   Increments number of written bytes (see args) or sets it to -1 in 
   112                                  ;   case of writing error.
   113                                  ; Args:
   114                                  ;   - r10b - char to store to buffer and print.
   115                                  ;   - eax  - stores number of already written bytes here, or sets it to -1
   116                                  ;           in case of error.
   117                                  ; Expects: 
   118                                  ;   - r11 - index in the buffer, must be set to 0 before first call of 
   119                                  ;           this func; must not be changed outside of this func.
   120                                  ; =======================================================================
   121                                  print_char:
   122 0000005F 4180FA00                            cmp r10b, 0x0
   123 00000063 7416                                je flush_buf
   124                                  
   125 00000065 83F8FF                              cmp eax, -1     ; check if error already happened
   126 00000068 7437                                je prn_chr_end
   127                                  
   128 0000006A 458893[00000000]                    mov [charbuf + r11], r10b
   129 00000071 49FFC3                              inc r11
   130                                  
   131 00000074 4983FB0A                            cmp r11, CHARBUF_SIZE
   132 00000078 7401                                je flush_buf
   133                                              
   134 0000007A C3                                  ret
   135                                  
   136                                  flush_buf:  
   137 0000007B 57                                  push rdi
   138 0000007C 56                                  push rsi
   139 0000007D 52                                  push rdx
   140 0000007E 50                                  push rax 
   141                                  
   142 0000007F 4C89DA                              mov rdx, r11            ; num of bytes to write
   143 00000082 B801000000                          mov rax, 0x1            ; syscall number - write
   144 00000087 BF01000000                          mov rdi, 0x1            ; stdout
   145 0000008C 488D3425[00000000]                  lea rsi, [charbuf]      ; buffer pointer
   146 00000094 0F05                                syscall
   147                                  
   148                                              ; now eax stores -1 or number of written bytes
   149 00000096 83F8FF                              cmp eax, -1
   150 00000099 7406                                je prn_chr_end
   151 0000009B 030424                              add eax, [rsp] ; adding to eax its previous value 
   152                                  
   153 0000009E 4D31DB                              xor r11, r11
   154                                  
   155                                  prn_chr_end: 
   156                                              ; if eax equals -1, it must be -1 still; otherwise
   157                                              ; it already has the needed value
   158 000000A1 4883C408                            add rsp, 0x8    ; skipping eax
   159                                  
   160 000000A5 5A                                  pop rdx
   161 000000A6 5E                                  pop rsi
   162 000000A7 5F                                  pop rdi
   163 000000A8 C3                                  ret
   164                                  
   165                                  ; =======================================================================
   166                                  ; hndl_specf - DON'T USE CALL, USE JMP
   167                                  ; Description:
   168                                  ;   Handles situation when specifier like '%S' is met in the format 
   169                                  ;   string. 'S' fully specifier which specifier it is.
   170                                  ; Supported specifiers (case sensitive!):
   171                                  ;   - %%    - just one character '%'   - no arg;
   172                                  ;   - %c    - one character            - uint8_t (unsigned char)
   173                                  ;   - %s    - C-string                 - const char *
   174                                  ;   - %d    - decimal integer          - int32_t
   175                                  ;   - %x    - hex integer              - int32_t
   176                                  ;   - %o    - octal integer            - int32_t
   177                                  ;   - %b    - binary integer           - int32_t
   178                                  ; Arguments:
   179                                  ;   - r10   - the character 'S' (see description)
   180                                  ; Expects:
   181                                  ;   - rbp - to point at the next to be used argument in stack 
   182                                  ;           (considering all args as 8 bytes)
   183                                  ; ATTENTION:
   184                                  ;   Nothing happens if the specifier is not identified.
   185                                  ; =======================================================================
   186                                  hndl_specf:
   187                                  %define SPECF_SMALLEST 'b' ; specifier with the smallest ascii value
   188                                  %define SPECF_BIGGEST  'x' ; specifier with the biggest ascii value
   189                                  
   190 000000A9 4180FA25                            cmp r10b, '%'           ; doesn't need arg, handled separately
   191 000000AD 741A                                je specf_perc
   192                                  
   193 000000AF 4180FA78                            cmp r10b, SPECF_BIGGEST ; if unrecognized, skip
   194 000000B3 7795                                ja hndl_specf_end       
   195                                  
   196                                              ; all the rest need an arg, getting it into rsi
   197 000000B5 488B7500                            mov rsi, [rbp]
   198 000000B9 4883C508                            add rbp, 0x8
   199                                  
   200                                              ; and now jmp to corresponding specifier handler
   201 000000BD 4180EA62                            sub r10b, SPECF_SMALLEST
   202 000000C1 42FF24D5[00000000]                  jmp [jmp_table + r10*8]
   203                                  
   204                                              ; treating '%%' specially
   205 000000C9 E891FFFFFF              specf_perc: call print_char ; just print '%', which is already in the r10b 
   206 000000CE E977FFFFFF                          jmp hndl_specf_end
   207                                  
   208                                              ; there is no ret, because every specifier handler jmps to
   209                                              ; label 'hndl_specf_end', which is located in the main loop
   210                                  ; =======================================================================
   211                                  ; Specifiers handlers. 
   212                                  ; Expects:
   213                                  ;    Each of them expects the argument to be in rsi.
   214                                  ; =======================================================================
   215                                  ;//REVIEW - можно было написать все преобразования (b, o, x) однообразно
   216                                  ; и с помощью одного макроса, но стоит ли оно того?
   217                                  specf_b:    
   218                                  
   219 000000D3 4989F2                  specf_c:    mov r10, rsi
   220 000000D6 E884FFFFFF                          call print_char
   221 000000DB E96AFFFFFF                          jmp hndl_specf_end
   222                                  
   223                                  specf_d:    
   224                                  
   225                                  specf_o:
   226                                  
   227                                  specf_s:
   228                                  
   229                                  specf_x:
   230                                  
   231                                  
   232                                  section .rodata
   233                                  align 8
   234                                  jmp_table:
   235 00000000 [D300000000000000]      dq specf_b
   236 00000008 [D300000000000000]      dq specf_c
   237 00000010 [E000000000000000]      dq specf_d
   238 00000018 [4A00000000000000]      dq hndl_specf_end
   239 00000020 [4A00000000000000]      dq hndl_specf_end
   240 00000028 [4A00000000000000]      dq hndl_specf_end
   241 00000030 [4A00000000000000]      dq hndl_specf_end
   242 00000038 [4A00000000000000]      dq hndl_specf_end
   243 00000040 [4A00000000000000]      dq hndl_specf_end
   244 00000048 [4A00000000000000]      dq hndl_specf_end
   245 00000050 [4A00000000000000]      dq hndl_specf_end
   246 00000058 [4A00000000000000]      dq hndl_specf_end
   247 00000060 [E000000000000000]      dq specf_o
   248 00000068 [4A00000000000000]      dq hndl_specf_end
   249 00000070 [4A00000000000000]      dq hndl_specf_end
   250 00000078 [4A00000000000000]      dq hndl_specf_end
   251 00000080 [E000000000000000]      dq specf_s
   252 00000088 [4A00000000000000]      dq hndl_specf_end
   253 00000090 [4A00000000000000]      dq hndl_specf_end
   254 00000098 [4A00000000000000]      dq hndl_specf_end
   255 000000A0 [4A00000000000000]      dq hndl_specf_end
   256 000000A8 [E000000000000000]      dq specf_x
   257                                  
   258                                  section .data
   259                                  
   260 00000000 000000000000000000-     charbuf: db CHARBUF_SIZE dup(0)
   260 00000009 00                 
