     1                                  ; =======================================================================
     2                                  ; int myprintf(const char *format, ...)
     3                                  ; Supported specifiers (case sensitive!):
     4                                  ;   - %%    - just one character '%'   - no arg;
     5                                  ;   - %c    - one character            - uint8_t (unsigned char)
     6                                  ;   - %s    - C-string                 - const char *
     7                                  ;   - %d    - decimal integer          - int32_t
     8                                  ;   - %x    - hex integer              - uint32_t
     9                                  ;   - %o    - octal integer            - uint32_t
    10                                  ;   - %b    - binary integer           - uint32_t
    11                                  ; Use of registers (throughot the whole func):
    12                                  ;   - eax - num of written chars (is returned)
    13                                  ;   - rdi - points at the current char in the format string
    14                                  ;   - rbp - base in stack to access arranged arguments
    15                                  ;   - r11 - index in the buffer of func 'print_char'
    16                                  ;   
    17                                  ; =======================================================================
    18                                  
    19                                  %define GLOBAL_FUNC_NAME _Z9my_printfPKcz
    20                                  %define CHARBUF_SIZE 16
    21                                  
    22                                  global GLOBAL_FUNC_NAME
    23                                  ;//TODO - исправить rsi на esi, потому что блин int, а не long
    24                                  section .text
    25                                  
    26                                  GLOBAL_FUNC_NAME:
    27                                              ; ============================================    
    28                                              ; preparing stack frame, so that all POTENTIAL
    29                                              ; arguments are located in order in stack
    30                                  
    31 00000000 415A                                pop r10 ; saving ret code
    32                                  
    33                                              ; pushing POTENTIAL arguments in reverse order
    34 00000002 4151                                push r9
    35 00000004 4150                                push r8
    36 00000006 51                                  push rcx
    37 00000007 52                                  push rdx
    38 00000008 56                                  push rsi
    39                                  
    40 00000009 4989E3                              mov r11, rsp ; saving reference stack pointer
    41                                  
    42 0000000C 4152                                push r10 ; pushing ret code
    43                                  
    44                                              ; ============================================
    45 0000000E 53                                  push rbx
    46 0000000F 55                                  push rbp
    47 00000010 4154                                push r12
    48 00000012 4155                                push r13 
    49 00000014 4156                                push r14
    50 00000016 4157                                push r15
    51                                  
    52 00000018 4C89DD                              mov rbp, r11 ; now r11 is free
    53                                  
    54                                              ; before first call of print_char
    55 0000001B 31C0                                xor eax, eax
    56 0000001D 4D31DB                              xor r11, r11
    57 00000020 4D31D2                              xor r10, r10
    58                                  
    59                                              ; =====================================
    60                                              ; main loop
    61 00000023 448A17                  main_loop:  mov r10b, [rdi]
    62 00000026 48FFC7                              inc rdi
    63                                              
    64 00000029 4180FA25                            cmp r10b, '%'
    65 0000002D 740D                                je specf
    66                                              
    67                                              ; common char or 0x0
    68 0000002F E825000000                          call print_char
    69                                  
    70 00000034 4180FA00                            cmp r10b, 0x0
    71 00000038 75E9                                jne main_loop
    72 0000003A EB0A                                jmp printf_end
    73                                              ; ---------------
    74                                              ; specf
    75 0000003C 448A17                  specf:      mov r10b, [rdi]
    76 0000003F 48FFC7                              inc rdi
    77 00000042 EB5F                                jmp hndl_specf
    78                                              ; ------------------------------------
    79                                              ; back to loop, if not 0x0
    80                                  hndl_specf_end:
    81 00000044 EBDD                                jmp main_loop
    82                                              ; =====================================
    83                                              ; end of main_loop
    84                                  printf_end: 
    85                                   
    86 00000046 415F                                pop r15
    87 00000048 415E                                pop r14
    88 0000004A 415D                                pop r13
    89 0000004C 415C                                pop r12
    90 0000004E 5D                                  pop rbp
    91 0000004F 5B                                  pop rbx
    92                                  
    93                                              ; ======================================
    94                                              ; fixig stack frame and ret
    95                                  
    96 00000050 415B                                pop r11         ; popping ret code
    97 00000052 4883C428                            add rsp, 5*8    ; throwing out potential register args
    98 00000056 4153                                push r11        ; ret code
    99 00000058 C3                                  ret
   100                                  
   101                                  ; =======================================================================
   102                                  ; print_char
   103                                  ; Description:
   104                                  ;   Gets one char, stores it into internal buffer. When it's full, calls
   105                                  ;   syscall write to stdout and resets the buffer. If given char is zero 
   106                                  ;   byte ('\0'), doesn't store it and flushes buffer immediately. 
   107                                  ;   Increments number of written bytes (see args) or sets it to -1 in 
   108                                  ;   case of writing error.
   109                                  ; Args:
   110                                  ;   - r10b - char to store to buffer and print.
   111                                  ;   - eax  - stores number of already written bytes here, or sets it to -1
   112                                  ;           in case of error. Must be set to 0 before first call of 
   113                                  ;           this func.
   114                                  ; Expects: 
   115                                  ;   - r11 - index in the buffer, must be set to 0 before first call of 
   116                                  ;           this func; must not be changed outside of this func.
   117                                  ; =======================================================================
   118                                  print_char:
   119 00000059 4180FA00                            cmp r10b, 0x0
   120 0000005D 7416                                je flush_buf
   121                                  
   122 0000005F 83F8FF                              cmp eax, -1     ; check if error already happened
   123 00000062 7437                                je prn_chr_end
   124                                  
   125 00000064 458893[00000000]                    mov [charbuf + r11], r10b
   126 0000006B 49FFC3                              inc r11
   127                                  
   128 0000006E 4983FB10                            cmp r11, CHARBUF_SIZE
   129 00000072 7401                                je flush_buf
   130                                              
   131 00000074 C3                                  ret
   132                                  
   133                                  flush_buf:  
   134 00000075 57                                  push rdi
   135 00000076 56                                  push rsi
   136 00000077 52                                  push rdx
   137 00000078 50                                  push rax 
   138                                  
   139 00000079 4C89DA                              mov rdx, r11            ; num of bytes to write
   140 0000007C B801000000                          mov rax, 0x1            ; syscall number - write
   141 00000081 BF01000000                          mov rdi, 0x1            ; stdout
   142 00000086 488D3425[00000000]                  lea rsi, [charbuf]      ; buffer pointer
   143 0000008E 0F05                                syscall
   144                                  
   145                                              ; now eax stores -1 or number of written bytes
   146 00000090 83F8FF                              cmp eax, -1
   147 00000093 7406                                je prn_chr_end
   148 00000095 030424                              add eax, [rsp] ; adding to eax its previous value 
   149                                  
   150 00000098 4D31DB                              xor r11, r11
   151                                  
   152                                  prn_chr_end: 
   153                                              ; if eax equals -1, it must be -1 still; otherwise
   154                                              ; it already has the needed value
   155 0000009B 4883C408                            add rsp, 0x8    ; skipping eax
   156                                  
   157 0000009F 5A                                  pop rdx
   158 000000A0 5E                                  pop rsi
   159 000000A1 5F                                  pop rdi
   160 000000A2 C3                                  ret
   161                                  
   162                                  ; =======================================================================
   163                                  ; hndl_specf - DON'T USE CALL, USE JMP
   164                                  ; Description:
   165                                  ;   Handles situation when specifier like '%S' is met in the format 
   166                                  ;   string. 'S' fully specifier which specifier it is.
   167                                  ; Supported specifiers (case sensitive!):
   168                                  ;   - %%    - just one character '%'   - no arg;
   169                                  ;   - %c    - one character            - uint8_t (unsigned char)
   170                                  ;   - %s    - C-string                 - const char *
   171                                  ;   - %d    - decimal integer          - int32_t
   172                                  ;   - %x    - hex integer              - uint32_t
   173                                  ;   - %o    - octal integer            - uint32_t
   174                                  ;   - %b    - binary integer           - uint32_t
   175                                  ; Arguments:
   176                                  ;   - r10   - the character 'S' (see description)
   177                                  ; Expects:
   178                                  ;   - rbp - to point at the next to be used argument in stack 
   179                                  ;           (considering all args as 8 bytes)
   180                                  ; ATTENTION:
   181                                  ;   Nothing happens if the specifier is not identified.
   182                                  ; =======================================================================
   183                                  hndl_specf:
   184                                  %define SPECF_SMALLEST 'b' ; specifier with the smallest ascii value
   185                                  %define SPECF_BIGGEST  'x' ; specifier with the biggest ascii value
   186                                  
   187 000000A3 4180FA25                            cmp r10b, '%'           ; doesn't need arg, handled separately
   188 000000A7 741A                                je specf_perc
   189                                  
   190 000000A9 4180FA78                            cmp r10b, SPECF_BIGGEST ; if unrecognized, skip
   191 000000AD 7795                                ja hndl_specf_end       
   192                                  
   193                                              ; all the rest need an arg, getting it into rsi
   194 000000AF 488B7500                            mov rsi, [rbp]
   195 000000B3 4883C508                            add rbp, 0x8
   196                                  
   197                                              ; jmp to corresponding specifier handler
   198 000000B7 4180EA62                            sub r10b, SPECF_SMALLEST
   199 000000BB 42FF24D5[20000000]                  jmp [jmp_table + r10*8]
   200                                  
   201                                              ; treating '%%' specially
   202 000000C3 E891FFFFFF              specf_perc: call print_char ; just print '%', which is already in the r10b 
   203 000000C8 E977FFFFFF                          jmp hndl_specf_end
   204                                  
   205                                              ; there is no ret, because every specifier handler jmps to
   206                                              ; label 'hndl_specf_end', which is located in the main loop
   207                                  ; =======================================================================
   208                                  ; Specifiers handlers. 
   209                                  ; Expects:
   210                                  ;    Each of them expects the argument to be in rsi.
   211                                  ; ==========================================================================
   212                                  ; Macro for converting & printing, supports BIN, HEX (AND POTENTIALLY BASE 4)
   213                                  ; Macro argumets:
   214                                  ;   %1) number of bits to represent one digit (1 for BIN, 4 for HEX, etc)
   215                                  ;   %2) BIN | HEX
   216                                  ; Expects:
   217                                  ;   Number to convert and print in esi
   218                                  ; ==========================================================================
   219                                  %macro      ConvertBH 2
   220                                  
   221                                              xor rbx, rbx
   222                                  
   223                                              ; skipping leading zeroes
   224                                              mov ecx, 32 / %1
   225                                  %%nzero:    rol esi, %1
   226                                              mov bl, sil
   227                                              and bl, (1 << %1) - 1
   228                                              cmp bl, 0
   229                                              loope %%nzero
   230                                  
   231                                              jz %%num_0    ; the number to print is zero, special case
   232                                              ror esi, %1
   233                                              inc ecx
   234                                  
   235                                  %%loop:     rol esi, %1
   236                                              mov bl, sil
   237                                              and bl, (1 << %1) - 1
   238                                              mov r10b, [%2 + rbx]
   239                                              mov r12, rcx ; saving
   240                                              call print_char
   241                                              mov rcx, r12  
   242                                              loop %%loop
   243                                  
   244                                              jmp hndl_specf_end ; instead of ret
   245                                  
   246                                              ; if the number to print is 0
   247                                  %%num_0:    mov r10b, [%2]
   248                                              call print_char
   249                                  
   250                                              jmp hndl_specf_end ; instead of ret
   251                                  
   252                                  %endmacro
   253                                  ; ==========================================================================
   254                                  ; Macro for converting into bases [2, 10]
   255                                  ; Macro argumets:
   256                                  ;   %1) the base: 2, or 3, or 4... or 10
   257                                  ; Expects:
   258                                  ;   Number to convert and print in esi
   259                                  ; ==========================================================================
   260                                  %macro      ConvertCmn 1
   261                                              mov r12, rax    ; saving
   262                                  
   263                                              ; --------------------------------------------------------------
   264                                              ; if the base is 10 and number < 0, print '-' and convert
   265                                  %if %1 == 10
   266                                              test esi, 1 << 31
   267                                              jz %%skip_abs
   268                                              mov r10b, '-'
   269                                              call print_char
   270                                              neg esi
   271                                  %endif
   272                                  
   273                                  %%skip_abs: 
   274                                              xor rdx, rdx
   275                                              xor rax, rax
   276                                              mov eax, esi
   277                                              mov ebx, %1 ; because div doesn't support immc
   278                                              xor rcx, rcx
   279                                  
   280                                  %%loop_fw:  div ebx
   281                                              push rdx
   282                                              inc rcx
   283                                              xor rdx, rdx
   284                                              cmp eax, 0
   285                                              jne %%loop_fw
   286                                              
   287                                              mov rax, r12 ; restoring rax
   288                                  
   289                                  %%loop_bw:  pop r10
   290                                              add r10, '0'
   291                                              mov r12, rcx    ; saving
   292                                              call print_char
   293                                              mov rcx, r12
   294                                              loop %%loop_bw
   295                                  
   296                                  %endmacro
   297                                  ; ==========================================================================
   298                                  specf_b:    ConvertBH 1, BIN
   298                              <1> specf_b: 
   220                              <1> 
   221 000000CD 4831DB              <1>  xor rbx, rbx
   222                              <1> 
   223                              <1> 
   224 000000D0 B920000000          <1>  mov ecx, 32 / %1
   225 000000D5 D1C6                <1> %%nzero: rol esi, %1
   226 000000D7 4088F3              <1>  mov bl, sil
   227 000000DA 80E301              <1>  and bl, (1 << %1) - 1
   228 000000DD 80FB00              <1>  cmp bl, 0
   229 000000E0 E1F3                <1>  loope %%nzero
   230                              <1> 
   231 000000E2 7425                <1>  jz %%num_0
   232 000000E4 D1CE                <1>  ror esi, %1
   233 000000E6 FFC1                <1>  inc ecx
   234                              <1> 
   235 000000E8 D1C6                <1> %%loop: rol esi, %1
   236 000000EA 4088F3              <1>  mov bl, sil
   237 000000ED 80E301              <1>  and bl, (1 << %1) - 1
   238 000000F0 448A93[18000000]    <1>  mov r10b, [%2 + rbx]
   239 000000F7 4989CC              <1>  mov r12, rcx
   240 000000FA E85AFFFFFF          <1>  call print_char
   241 000000FF 4C89E1              <1>  mov rcx, r12
   242 00000102 E2E4                <1>  loop %%loop
   243                              <1> 
   244 00000104 E93BFFFFFF          <1>  jmp hndl_specf_end
   245                              <1> 
   246                              <1> 
   247 00000109 448A1425[18000000]  <1> %%num_0: mov r10b, [%2]
   248 00000111 E843FFFFFF          <1>  call print_char
   249                              <1> 
   250 00000116 E929FFFFFF          <1>  jmp hndl_specf_end
   251                              <1> 
   299                                  
   300 0000011B E924FFFFFF                          jmp hndl_specf_end ; instead of ret
   301                                  ; ==========================================================================
   302 00000120 4188F2                  specf_c:    mov r10b, sil
   303 00000123 E831FFFFFF                          call print_char
   304 00000128 E917FFFFFF                          jmp hndl_specf_end ; instead of ret
   305                                  ; ==========================================================================
   306                                  specf_d:    ConvertCmn 10
   306                              <1> specf_d: 
   261 0000012D 4989C4              <1>  mov r12, rax
   262                              <1> 
   263                              <1> 
   264                              <1> 
   265                              <1> %if %1 == 10
   266 00000130 F7C600000080        <1>  test esi, 1 << 31
   267 00000136 740A                <1>  jz %%skip_abs
   268 00000138 41B22D              <1>  mov r10b, '-'
   269 0000013B E819FFFFFF          <1>  call print_char
   270 00000140 F7DE                <1>  neg esi
   271                              <1> %endif
   272                              <1> 
   273                              <1> %%skip_abs:
   274 00000142 4831D2              <1>  xor rdx, rdx
   275 00000145 4831C0              <1>  xor rax, rax
   276 00000148 89F0                <1>  mov eax, esi
   277 0000014A BB0A000000          <1>  mov ebx, %1
   278 0000014F 4831C9              <1>  xor rcx, rcx
   279                              <1> 
   280 00000152 F7F3                <1> %%loop_fw: div ebx
   281 00000154 52                  <1>  push rdx
   282 00000155 48FFC1              <1>  inc rcx
   283 00000158 4831D2              <1>  xor rdx, rdx
   284 0000015B 83F800              <1>  cmp eax, 0
   285 0000015E 75F2                <1>  jne %%loop_fw
   286                              <1> 
   287 00000160 4C89E0              <1>  mov rax, r12
   288                              <1> 
   289 00000163 415A                <1> %%loop_bw: pop r10
   290 00000165 4983C230            <1>  add r10, '0'
   291 00000169 4989CC              <1>  mov r12, rcx
   292 0000016C E8E8FEFFFF          <1>  call print_char
   293 00000171 4C89E1              <1>  mov rcx, r12
   294 00000174 E2ED                <1>  loop %%loop_bw
   295                              <1> 
   307                                  
   308 00000176 E9C9FEFFFF                          jmp hndl_specf_end
   309                                  ; ==========================================================================
   310                                  specf_o:    ConvertCmn 8
   310                              <1> specf_o: 
   261 0000017B 4989C4              <1>  mov r12, rax
   262                              <1> 
   263                              <1> 
   264                              <1> 
   265                              <1> %if %1 == 10
   266                              <1>  test esi, 1 << 31
   267                              <1>  jz %%skip_abs
   268                              <1>  mov r10b, '-'
   269                              <1>  call print_char
   270                              <1>  neg esi
   271                              <1> %endif
   272                              <1> 
   273                              <1> %%skip_abs:
   274 0000017E 4831D2              <1>  xor rdx, rdx
   275 00000181 4831C0              <1>  xor rax, rax
   276 00000184 89F0                <1>  mov eax, esi
   277 00000186 BB08000000          <1>  mov ebx, %1
   278 0000018B 4831C9              <1>  xor rcx, rcx
   279                              <1> 
   280 0000018E F7F3                <1> %%loop_fw: div ebx
   281 00000190 52                  <1>  push rdx
   282 00000191 48FFC1              <1>  inc rcx
   283 00000194 4831D2              <1>  xor rdx, rdx
   284 00000197 83F800              <1>  cmp eax, 0
   285 0000019A 75F2                <1>  jne %%loop_fw
   286                              <1> 
   287 0000019C 4C89E0              <1>  mov rax, r12
   288                              <1> 
   289 0000019F 415A                <1> %%loop_bw: pop r10
   290 000001A1 4983C230            <1>  add r10, '0'
   291 000001A5 4989CC              <1>  mov r12, rcx
   292 000001A8 E8ACFEFFFF          <1>  call print_char
   293 000001AD 4C89E1              <1>  mov rcx, r12
   294 000001B0 E2ED                <1>  loop %%loop_bw
   295                              <1> 
   311                                  
   312 000001B2 E98DFEFFFF                          jmp hndl_specf_end
   313                                  ; ==========================================================================
   314                                  specf_s:    
   315 000001B7 448A16                  sp_s_loop:  mov r10b, [rsi]
   316 000001BA 48FFC6                              inc rsi
   317 000001BD E897FEFFFF                          call print_char
   318 000001C2 4180FA00                            cmp r10b, 0x0
   319 000001C6 75EF                                jne sp_s_loop
   320                                  
   321 000001C8 E977FEFFFF                          jmp hndl_specf_end
   322                                  ; ==========================================================================
   323                                  specf_x:    ConvertBH 4, HEX
   323                              <1> specf_x: 
   220                              <1> 
   221 000001CD 4831DB              <1>  xor rbx, rbx
   222                              <1> 
   223                              <1> 
   224 000001D0 B908000000          <1>  mov ecx, 32 / %1
   225 000001D5 C1C604              <1> %%nzero: rol esi, %1
   226 000001D8 4088F3              <1>  mov bl, sil
   227 000001DB 80E30F              <1>  and bl, (1 << %1) - 1
   228 000001DE 80FB00              <1>  cmp bl, 0
   229 000001E1 E1F2                <1>  loope %%nzero
   230                              <1> 
   231 000001E3 7427                <1>  jz %%num_0
   232 000001E5 C1CE04              <1>  ror esi, %1
   233 000001E8 FFC1                <1>  inc ecx
   234                              <1> 
   235 000001EA C1C604              <1> %%loop: rol esi, %1
   236 000001ED 4088F3              <1>  mov bl, sil
   237 000001F0 80E30F              <1>  and bl, (1 << %1) - 1
   238 000001F3 448A93[00000000]    <1>  mov r10b, [%2 + rbx]
   239 000001FA 4989CC              <1>  mov r12, rcx
   240 000001FD E857FEFFFF          <1>  call print_char
   241 00000202 4C89E1              <1>  mov rcx, r12
   242 00000205 E2E3                <1>  loop %%loop
   243                              <1> 
   244 00000207 E938FEFFFF          <1>  jmp hndl_specf_end
   245                              <1> 
   246                              <1> 
   247 0000020C 448A1425[00000000]  <1> %%num_0: mov r10b, [%2]
   248 00000214 E840FEFFFF          <1>  call print_char
   249                              <1> 
   250 00000219 E926FEFFFF          <1>  jmp hndl_specf_end
   251                              <1> 
   324                                  
   325 0000021E E921FEFFFF                          jmp hndl_specf_end ; instead of ret
   326                                  ; ==========================================================================
   327                                  section .rodata
   328 00000000 303132333435363738-     HEX:        db '0123456789ABCDEF' 
   328 00000009 39414243444546     
   329 00000010 3031323334353637        OCT:        db '01234567'
   330 00000018 3031                    BIN:        db '01'
   331                                  
   332 0000001A 90<rep 6h>              align 8
   333                                  jmp_table:
   334 00000020 [CD00000000000000]      dq specf_b
   335 00000028 [2001000000000000]      dq specf_c
   336 00000030 [2D01000000000000]      dq specf_d
   337 00000038 [4400000000000000]      dq hndl_specf_end
   338 00000040 [4400000000000000]      dq hndl_specf_end
   339 00000048 [4400000000000000]      dq hndl_specf_end
   340 00000050 [4400000000000000]      dq hndl_specf_end
   341 00000058 [4400000000000000]      dq hndl_specf_end
   342 00000060 [4400000000000000]      dq hndl_specf_end
   343 00000068 [4400000000000000]      dq hndl_specf_end
   344 00000070 [4400000000000000]      dq hndl_specf_end
   345 00000078 [4400000000000000]      dq hndl_specf_end
   346 00000080 [4400000000000000]      dq hndl_specf_end
   347 00000088 [7B01000000000000]      dq specf_o
   348 00000090 [4400000000000000]      dq hndl_specf_end
   349 00000098 [4400000000000000]      dq hndl_specf_end
   350 000000A0 [4400000000000000]      dq hndl_specf_end
   351 000000A8 [B701000000000000]      dq specf_s
   352 000000B0 [4400000000000000]      dq hndl_specf_end
   353 000000B8 [4400000000000000]      dq hndl_specf_end
   354 000000C0 [4400000000000000]      dq hndl_specf_end
   355 000000C8 [4400000000000000]      dq hndl_specf_end
   356 000000D0 [CD01000000000000]      dq specf_x
   357                                  
   358                                  section .data
   359                                  
   360 00000000 000000000000000000-     charbuf: db CHARBUF_SIZE dup(0)
   360 00000009 00000000000000     
