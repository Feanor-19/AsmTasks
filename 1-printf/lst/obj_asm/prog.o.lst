     1                                  ; =======================================================================
     2                                  ; int myprintf(const char *format, ...)
     3                                  ; Supported specifiers:
     4                                  ;   - %c - one character;
     5                                  ;   - %s - a c-string;
     6                                  ;   - %% - a single '%';
     7                                  ;   - %d - decimal integer (int32_t)
     8                                  ;   - %x - hex integer (uint32_t)
     9                                  ;   - %o - octal integer (uint32_t)
    10                                  ;   - %b - binary integer (uint32_t)
    11                                  ; =======================================================================
    12                                  
    13                                  %define GLOBAL_FUNC_NAME _Z9my_printfPKcz
    14                                  %define CHARBUF_SIZE 16
    15                                  
    16                                  global GLOBAL_FUNC_NAME
    17                                  ;//TODO - исправить rsi на esi, потому что блин int, а не long
    18                                  section .text
    19                                  
    20                                  GLOBAL_FUNC_NAME:
    21                                              ; ============================================    
    22                                              ; preparing stack frame, so that all POTENTIAL
    23                                              ; arguments are located in order in stack
    24                                  
    25 00000000 415A                                pop r10 ; saving ret code
    26                                  
    27                                              ; pushing POTENTIAL arguments in reverse order
    28 00000002 4151                                push r9
    29 00000004 4150                                push r8
    30 00000006 51                                  push rcx
    31 00000007 52                                  push rdx
    32 00000008 56                                  push rsi
    33                                  
    34 00000009 4989E3                              mov r11, rsp ; saving reference stack pointer
    35                                  
    36 0000000C 4152                                push r10 ; pushing ret code
    37                                  
    38                                              ; ============================================
    39 0000000E 53                                  push rbx
    40 0000000F 55                                  push rbp
    41 00000010 4154                                push r12
    42 00000012 4155                                push r13
    43 00000014 4156                                push r14
    44 00000016 4157                                push r15
    45                                  
    46 00000018 4C89DD                              mov rbp, r11 ; now r11 is free
    47                                  
    48                                              ; before first call of print_char
    49 0000001B 31C0                                xor eax, eax
    50 0000001D 4D31DB                              xor r11, r11
    51 00000020 4D31D2                              xor r10, r10
    52                                  
    53                                              ; =====================================
    54                                              ; main loop
    55 00000023 448A17                  main_loop:  mov r10b, [rdi]
    56 00000026 48FFC7                              inc rdi
    57                                              
    58 00000029 4180FA25                            cmp r10b, '%'
    59 0000002D 740D                                je specf
    60                                              
    61                                              ; common char or 0x0
    62 0000002F E825000000                          call print_char
    63                                  
    64 00000034 4180FA00                            cmp r10b, 0x0
    65 00000038 75E9                                jne main_loop
    66 0000003A EB0A                                jmp printf_end
    67                                              ; ---------------
    68                                              ; specf
    69 0000003C 448A17                  specf:      mov r10b, [rdi]
    70 0000003F 48FFC7                              inc rdi
    71 00000042 EB5F                                jmp hndl_specf
    72                                              ; ------------------------------------
    73                                              ; back to loop, if not 0x0
    74                                  hndl_specf_end:
    75 00000044 EBDD                                jmp main_loop
    76                                              ; =====================================
    77                                              ; end of main_loop
    78                                  printf_end: 
    79                                  
    80 00000046 415F                                pop r15
    81 00000048 415E                                pop r14
    82 0000004A 415D                                pop r13
    83 0000004C 415C                                pop r12
    84 0000004E 5D                                  pop rbp
    85 0000004F 5B                                  pop rbx
    86                                  
    87                                              ; ======================================
    88                                              ; fixig stack frame and ret
    89                                  
    90 00000050 415B                                pop r11         ; popping ret code
    91 00000052 4883C428                            add rsp, 5*8    ; throwing out potential register args
    92 00000056 4153                                push r11        ; ret code
    93 00000058 C3                                  ret
    94                                  
    95                                  ; =======================================================================
    96                                  ; print_char
    97                                  ; Description:
    98                                  ;   Gets one char, stores it into internal buffer. When it's full, calls
    99                                  ;   syscall write to stdout and resets the buffer. If given char is zero 
   100                                  ;   byte ('\0'), doesn't store it and flushes buffer immediately. 
   101                                  ;   Increments number of written bytes (see args) or sets it to -1 in 
   102                                  ;   case of writing error.
   103                                  ; Args:
   104                                  ;   - r10b - char to store to buffer and print.
   105                                  ;   - eax  - stores number of already written bytes here, or sets it to -1
   106                                  ;           in case of error.
   107                                  ; Expects: 
   108                                  ;   - r11 - index in the buffer, must be set to 0 before first call of 
   109                                  ;           this func; must not be changed outside of this func.
   110                                  ; =======================================================================
   111                                  print_char:
   112 00000059 4180FA00                            cmp r10b, 0x0
   113 0000005D 7416                                je flush_buf
   114                                  
   115 0000005F 83F8FF                              cmp eax, -1     ; check if error already happened
   116 00000062 7437                                je prn_chr_end
   117                                  
   118 00000064 458893[00000000]                    mov [charbuf + r11], r10b
   119 0000006B 49FFC3                              inc r11
   120                                  
   121 0000006E 4983FB10                            cmp r11, CHARBUF_SIZE
   122 00000072 7401                                je flush_buf
   123                                              
   124 00000074 C3                                  ret
   125                                  
   126                                  flush_buf:  
   127 00000075 57                                  push rdi
   128 00000076 56                                  push rsi
   129 00000077 52                                  push rdx
   130 00000078 50                                  push rax 
   131                                  
   132 00000079 4C89DA                              mov rdx, r11            ; num of bytes to write
   133 0000007C B801000000                          mov rax, 0x1            ; syscall number - write
   134 00000081 BF01000000                          mov rdi, 0x1            ; stdout
   135 00000086 488D3425[00000000]                  lea rsi, [charbuf]      ; buffer pointer
   136 0000008E 0F05                                syscall
   137                                  
   138                                              ; now eax stores -1 or number of written bytes
   139 00000090 83F8FF                              cmp eax, -1
   140 00000093 7406                                je prn_chr_end
   141 00000095 030424                              add eax, [rsp] ; adding to eax its previous value 
   142                                  
   143 00000098 4D31DB                              xor r11, r11
   144                                  
   145                                  prn_chr_end: 
   146                                              ; if eax equals -1, it must be -1 still; otherwise
   147                                              ; it already has the needed value
   148 0000009B 4883C408                            add rsp, 0x8    ; skipping eax
   149                                  
   150 0000009F 5A                                  pop rdx
   151 000000A0 5E                                  pop rsi
   152 000000A1 5F                                  pop rdi
   153 000000A2 C3                                  ret
   154                                  
   155                                  ; =======================================================================
   156                                  ; hndl_specf - DON'T USE CALL, USE JMP
   157                                  ; Description:
   158                                  ;   Handles situation when specifier like '%S' is met in the format 
   159                                  ;   string. 'S' fully specifier which specifier it is.
   160                                  ; Supported specifiers (case sensitive!):
   161                                  ;   - %%    - just one character '%'   - no arg;
   162                                  ;   - %c    - one character            - uint8_t (unsigned char)
   163                                  ;   - %s    - C-string                 - const char *
   164                                  ;   - %d    - decimal integer          - int32_t
   165                                  ;   - %x    - hex integer              - int32_t
   166                                  ;   - %o    - octal integer            - int32_t
   167                                  ;   - %b    - binary integer           - int32_t
   168                                  ; Arguments:
   169                                  ;   - r10   - the character 'S' (see description)
   170                                  ; Expects:
   171                                  ;   - rbp - to point at the next to be used argument in stack 
   172                                  ;           (considering all args as 8 bytes)
   173                                  ; ATTENTION:
   174                                  ;   Nothing happens if the specifier is not identified.
   175                                  ; =======================================================================
   176                                  hndl_specf:
   177                                  %define SPECF_SMALLEST 'b' ; specifier with the smallest ascii value
   178                                  %define SPECF_BIGGEST  'x' ; specifier with the biggest ascii value
   179                                  
   180 000000A3 4180FA25                            cmp r10b, '%'           ; doesn't need arg, handled separately
   181 000000A7 741A                                je specf_perc
   182                                  
   183 000000A9 4180FA78                            cmp r10b, SPECF_BIGGEST ; if unrecognized, skip
   184 000000AD 7795                                ja hndl_specf_end       
   185                                  
   186                                              ; all the rest need an arg, getting it into rsi
   187 000000AF 488B7500                            mov rsi, [rbp]
   188 000000B3 4883C508                            add rbp, 0x8
   189                                  
   190                                              ; and now jmp to corresponding specifier handler
   191 000000B7 4180EA62                            sub r10b, SPECF_SMALLEST
   192 000000BB 42FF24D5[20000000]                  jmp [jmp_table + r10*8]
   193                                  
   194                                              ; treating '%%' specially
   195 000000C3 E891FFFFFF              specf_perc: call print_char ; just print '%', which is already in the r10b 
   196 000000C8 E977FFFFFF                          jmp hndl_specf_end
   197                                  
   198                                              ; there is no ret, because every specifier handler jmps to
   199                                              ; label 'hndl_specf_end', which is located in the main loop
   200                                  ; =======================================================================
   201                                  ; Specifiers handlers. 
   202                                  ; Expects:
   203                                  ;    Each of them expects the argument to be in rsi.
   204                                  ; ==========================================================================
   205                                  ; Macro for converting & printing, supports BIN, HEX (AND POTENTIALLY BASE 4)
   206                                  ; Macro argumets:
   207                                  ;   %1) number of bits to represent one digit (1 for BIN, 4 for HEX, etc)
   208                                  ;   %2) BIN | HEX
   209                                  ; Expects:
   210                                  ;   Number to convert and print in rsi
   211                                  ; ==========================================================================
   212                                  %macro      ConvertBH 2
   213                                  
   214                                              xor rbx, rbx
   215                                  
   216                                              ; skipping leading zeroes
   217                                              mov ecx, 64 / %1
   218                                  %%nzero:    rol rsi, %1
   219                                              mov bl, sil
   220                                              and bl, (1 << %1) - 1
   221                                              cmp bl, 0
   222                                              loope %%nzero
   223                                  
   224                                              jz %%num_0    ; the number to print is zero, special case
   225                                              ror rsi, %1
   226                                              inc ecx
   227                                  
   228                                  %%loop:     rol rsi, %1
   229                                              mov bl, sil
   230                                              and bl, (1 << %1) - 1
   231                                              mov r10b, [%2 + rbx]
   232                                              mov r12, rcx ; saving
   233                                              call print_char
   234                                              mov rcx, r12  
   235                                              loop %%loop
   236                                  
   237                                              jmp hndl_specf_end ; instead of ret
   238                                  
   239                                              ; if the number to print is 0
   240                                  %%num_0:    mov r10b, [%2]
   241                                              call print_char
   242                                  
   243                                              jmp hndl_specf_end ; instead of ret
   244                                  
   245                                  %endmacro
   246                                  ; ==========================================================================
   247                                  ; Macro for converting into bases [2, 10]
   248                                  ; Macro argumets:
   249                                  ;   %1) the base: 2, or 3, or 4... or 10
   250                                  ; Expects:
   251                                  ;   Number to convert and print in esi
   252                                  ; ==========================================================================
   253                                  %macro      ConvertCmn 1
   254                                              mov r12, rax    ; saving
   255                                  
   256                                              ; --------------------------------------------------------------
   257                                              ; if the base is 10 and number < 0, print '-' and convert
   258                                  %if %1 == 10
   259                                              test esi, 1 << 31
   260                                              jz %%skip_abs
   261                                              mov r10b, '-'
   262                                              call print_char
   263                                              neg esi
   264                                  %endif
   265                                  
   266                                  %%skip_abs: 
   267                                              xor rdx, rdx
   268                                              xor rax, rax
   269                                              mov eax, esi
   270                                              mov ebx, %1 ; because div doesn't support immc
   271                                              xor rcx, rcx
   272                                  
   273                                  %%loop_fw:  div ebx
   274                                              push rdx
   275                                              inc rcx
   276                                              xor rdx, rdx
   277                                              cmp eax, 0
   278                                              jne %%loop_fw
   279                                              
   280                                              mov rax, r12 ; restoring rax
   281                                  
   282                                  %%loop_bw:  pop r10
   283                                              add r10, '0'
   284                                              mov r12, rcx    ; saving
   285                                              call print_char
   286                                              mov rcx, r12
   287                                              loop %%loop_bw
   288                                  
   289                                  %endmacro
   290                                  ; ==========================================================================
   291                                  specf_b:    ConvertBH 1, BIN
   291                              <1> specf_b: 
   213                              <1> 
   214 000000CD 4831DB              <1>  xor rbx, rbx
   215                              <1> 
   216                              <1> 
   217 000000D0 B940000000          <1>  mov ecx, 64 / %1
   218 000000D5 48D1C6              <1> %%nzero: rol rsi, %1
   219 000000D8 4088F3              <1>  mov bl, sil
   220 000000DB 80E301              <1>  and bl, (1 << %1) - 1
   221 000000DE 80FB00              <1>  cmp bl, 0
   222 000000E1 E1F2                <1>  loope %%nzero
   223                              <1> 
   224 000000E3 7427                <1>  jz %%num_0
   225 000000E5 48D1CE              <1>  ror rsi, %1
   226 000000E8 FFC1                <1>  inc ecx
   227                              <1> 
   228 000000EA 48D1C6              <1> %%loop: rol rsi, %1
   229 000000ED 4088F3              <1>  mov bl, sil
   230 000000F0 80E301              <1>  and bl, (1 << %1) - 1
   231 000000F3 448A93[18000000]    <1>  mov r10b, [%2 + rbx]
   232 000000FA 4989CC              <1>  mov r12, rcx
   233 000000FD E857FFFFFF          <1>  call print_char
   234 00000102 4C89E1              <1>  mov rcx, r12
   235 00000105 E2E3                <1>  loop %%loop
   236                              <1> 
   237 00000107 E938FFFFFF          <1>  jmp hndl_specf_end
   238                              <1> 
   239                              <1> 
   240 0000010C 448A1425[18000000]  <1> %%num_0: mov r10b, [%2]
   241 00000114 E840FFFFFF          <1>  call print_char
   242                              <1> 
   243 00000119 E926FFFFFF          <1>  jmp hndl_specf_end
   244                              <1> 
   292                                  
   293 0000011E E921FFFFFF                          jmp hndl_specf_end ; instead of ret
   294                                  ; ==========================================================================
   295 00000123 4989F2                  specf_c:    mov r10, rsi
   296 00000126 E82EFFFFFF                          call print_char
   297 0000012B E914FFFFFF                          jmp hndl_specf_end ; instead of ret
   298                                  ; ==========================================================================
   299                                  specf_d:    ConvertCmn 10
   299                              <1> specf_d: 
   254 00000130 4989C4              <1>  mov r12, rax
   255                              <1> 
   256                              <1> 
   257                              <1> 
   258                              <1> %if %1 == 10
   259 00000133 F7C600000080        <1>  test esi, 1 << 31
   260 00000139 740A                <1>  jz %%skip_abs
   261 0000013B 41B22D              <1>  mov r10b, '-'
   262 0000013E E816FFFFFF          <1>  call print_char
   263 00000143 F7DE                <1>  neg esi
   264                              <1> %endif
   265                              <1> 
   266                              <1> %%skip_abs:
   267 00000145 4831D2              <1>  xor rdx, rdx
   268 00000148 4831C0              <1>  xor rax, rax
   269 0000014B 89F0                <1>  mov eax, esi
   270 0000014D BB0A000000          <1>  mov ebx, %1
   271 00000152 4831C9              <1>  xor rcx, rcx
   272                              <1> 
   273 00000155 F7F3                <1> %%loop_fw: div ebx
   274 00000157 52                  <1>  push rdx
   275 00000158 48FFC1              <1>  inc rcx
   276 0000015B 4831D2              <1>  xor rdx, rdx
   277 0000015E 83F800              <1>  cmp eax, 0
   278 00000161 75F2                <1>  jne %%loop_fw
   279                              <1> 
   280 00000163 4C89E0              <1>  mov rax, r12
   281                              <1> 
   282 00000166 415A                <1> %%loop_bw: pop r10
   283 00000168 4983C230            <1>  add r10, '0'
   284 0000016C 4989CC              <1>  mov r12, rcx
   285 0000016F E8E5FEFFFF          <1>  call print_char
   286 00000174 4C89E1              <1>  mov rcx, r12
   287 00000177 E2ED                <1>  loop %%loop_bw
   288                              <1> 
   300                                  
   301 00000179 E9C6FEFFFF                          jmp hndl_specf_end
   302                                  ; ==========================================================================
   303                                  specf_o:    ConvertCmn 8
   303                              <1> specf_o: 
   254 0000017E 4989C4              <1>  mov r12, rax
   255                              <1> 
   256                              <1> 
   257                              <1> 
   258                              <1> %if %1 == 10
   259                              <1>  test esi, 1 << 31
   260                              <1>  jz %%skip_abs
   261                              <1>  mov r10b, '-'
   262                              <1>  call print_char
   263                              <1>  neg esi
   264                              <1> %endif
   265                              <1> 
   266                              <1> %%skip_abs:
   267 00000181 4831D2              <1>  xor rdx, rdx
   268 00000184 4831C0              <1>  xor rax, rax
   269 00000187 89F0                <1>  mov eax, esi
   270 00000189 BB08000000          <1>  mov ebx, %1
   271 0000018E 4831C9              <1>  xor rcx, rcx
   272                              <1> 
   273 00000191 F7F3                <1> %%loop_fw: div ebx
   274 00000193 52                  <1>  push rdx
   275 00000194 48FFC1              <1>  inc rcx
   276 00000197 4831D2              <1>  xor rdx, rdx
   277 0000019A 83F800              <1>  cmp eax, 0
   278 0000019D 75F2                <1>  jne %%loop_fw
   279                              <1> 
   280 0000019F 4C89E0              <1>  mov rax, r12
   281                              <1> 
   282 000001A2 415A                <1> %%loop_bw: pop r10
   283 000001A4 4983C230            <1>  add r10, '0'
   284 000001A8 4989CC              <1>  mov r12, rcx
   285 000001AB E8A9FEFFFF          <1>  call print_char
   286 000001B0 4C89E1              <1>  mov rcx, r12
   287 000001B3 E2ED                <1>  loop %%loop_bw
   288                              <1> 
   304                                  
   305 000001B5 E98AFEFFFF                          jmp hndl_specf_end
   306                                  ; ==========================================================================
   307                                  specf_s:    
   308 000001BA 448A16                  sp_s_loop:  mov r10b, [rsi]
   309 000001BD 48FFC6                              inc rsi
   310 000001C0 E894FEFFFF                          call print_char
   311 000001C5 4180FA00                            cmp r10b, 0x0
   312 000001C9 75EF                                jne sp_s_loop
   313                                  
   314 000001CB E974FEFFFF                          jmp hndl_specf_end
   315                                  ; ==========================================================================
   316                                  specf_x:    ConvertBH 4, HEX
   316                              <1> specf_x: 
   213                              <1> 
   214 000001D0 4831DB              <1>  xor rbx, rbx
   215                              <1> 
   216                              <1> 
   217 000001D3 B910000000          <1>  mov ecx, 64 / %1
   218 000001D8 48C1C604            <1> %%nzero: rol rsi, %1
   219 000001DC 4088F3              <1>  mov bl, sil
   220 000001DF 80E30F              <1>  and bl, (1 << %1) - 1
   221 000001E2 80FB00              <1>  cmp bl, 0
   222 000001E5 E1F1                <1>  loope %%nzero
   223                              <1> 
   224 000001E7 7429                <1>  jz %%num_0
   225 000001E9 48C1CE04            <1>  ror rsi, %1
   226 000001ED FFC1                <1>  inc ecx
   227                              <1> 
   228 000001EF 48C1C604            <1> %%loop: rol rsi, %1
   229 000001F3 4088F3              <1>  mov bl, sil
   230 000001F6 80E30F              <1>  and bl, (1 << %1) - 1
   231 000001F9 448A93[00000000]    <1>  mov r10b, [%2 + rbx]
   232 00000200 4989CC              <1>  mov r12, rcx
   233 00000203 E851FEFFFF          <1>  call print_char
   234 00000208 4C89E1              <1>  mov rcx, r12
   235 0000020B E2E2                <1>  loop %%loop
   236                              <1> 
   237 0000020D E932FEFFFF          <1>  jmp hndl_specf_end
   238                              <1> 
   239                              <1> 
   240 00000212 448A1425[00000000]  <1> %%num_0: mov r10b, [%2]
   241 0000021A E83AFEFFFF          <1>  call print_char
   242                              <1> 
   243 0000021F E920FEFFFF          <1>  jmp hndl_specf_end
   244                              <1> 
   317                                  
   318 00000224 E91BFEFFFF                          jmp hndl_specf_end ; instead of ret
   319                                  ; ==========================================================================
   320                                  section .rodata
   321 00000000 303132333435363738-     HEX:        db '0123456789ABCDEF' 
   321 00000009 39414243444546     
   322 00000010 3031323334353637        OCT:        db '01234567'
   323 00000018 3031                    BIN:        db '01'
   324                                  
   325 0000001A 90<rep 6h>              align 8
   326                                  jmp_table:
   327 00000020 [CD00000000000000]      dq specf_b
   328 00000028 [2301000000000000]      dq specf_c
   329 00000030 [3001000000000000]      dq specf_d
   330 00000038 [4400000000000000]      dq hndl_specf_end
   331 00000040 [4400000000000000]      dq hndl_specf_end
   332 00000048 [4400000000000000]      dq hndl_specf_end
   333 00000050 [4400000000000000]      dq hndl_specf_end
   334 00000058 [4400000000000000]      dq hndl_specf_end
   335 00000060 [4400000000000000]      dq hndl_specf_end
   336 00000068 [4400000000000000]      dq hndl_specf_end
   337 00000070 [4400000000000000]      dq hndl_specf_end
   338 00000078 [4400000000000000]      dq hndl_specf_end
   339 00000080 [4400000000000000]      dq hndl_specf_end
   340 00000088 [7E01000000000000]      dq specf_o
   341 00000090 [4400000000000000]      dq hndl_specf_end
   342 00000098 [4400000000000000]      dq hndl_specf_end
   343 000000A0 [4400000000000000]      dq hndl_specf_end
   344 000000A8 [BA01000000000000]      dq specf_s
   345 000000B0 [4400000000000000]      dq hndl_specf_end
   346 000000B8 [4400000000000000]      dq hndl_specf_end
   347 000000C0 [4400000000000000]      dq hndl_specf_end
   348 000000C8 [4400000000000000]      dq hndl_specf_end
   349 000000D0 [D001000000000000]      dq specf_x
   350                                  
   351                                  section .data
   352                                  
   353 00000000 000000000000000000-     charbuf: db CHARBUF_SIZE dup(0)
   353 00000009 00000000000000     
